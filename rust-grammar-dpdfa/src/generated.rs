// This file is automatically @generated by `grammar-gen`.
// It is not intended for manual editing.
// See the documentation in `expandable` for more information:
// https://github.com/scrabsha/expandable

#![allow(unused, non_snake_case)]
use std::{
    hash::{Hash, Hasher},
    mem,
};

use smallvec::SmallVec;
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub enum TokenDescription {
    Ident,
    As,
    Async,
    Await,
    Break,
    Const,
    Continue,
    Crate,
    Dyn,
    Else,
    Enum,
    Extern,
    False,
    Fn,
    For,
    If,
    Impl,
    In,
    Let,
    Loop,
    Match,
    Mod,
    Move,
    Mut,
    Pub,
    Ref,
    Return,
    Self_,
    SelfUpper,
    Static,
    Struct,
    Super,
    Trait,
    True,
    Type,
    Union,
    Unsafe,
    Use,
    Where,
    While,
    Yield,
    Abstract,
    Become,
    Box,
    Do,
    Final,
    Macro,
    Override,
    Priv,
    Try,
    Typeof,
    Unsized,
    Virtual,
    Literal,
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Caret,
    Not,
    And,
    Or,
    AndAnd,
    OrOr,
    Shl,
    Shr,
    PlusEquals,
    MinusEquals,
    StarEquals,
    SlashEquals,
    PercentEquals,
    CaretEquals,
    AndEquals,
    OrEquals,
    ShlEquals,
    ShrEquals,
    Equals,
    EqualsEquals,
    NotEquals,
    GreaterThan,
    LessThan,
    GreaterThanEquals,
    LessThanEquals,
    At,
    Underscore,
    Dot,
    DotDot,
    DotDotDot,
    DotDotEquals,
    Comma,
    Semicolon,
    Colon,
    ColonColon,
    RightArrow,
    FatArrow,
    Pound,
    Dollar,
    QuestionMark,
    LParen,
    RParen,
    LBracket,
    RBracket,
    LBrace,
    RBrace,
    FragmentBlock,
    FragmentExpr,
    FragmentIdent,
    FragmentItem,
    FragmentLifetime,
    FragmentLiteral,
    FragmentMeta,
    FragmentPat,
    FragmentPath,
    FragmentStmt,
    FragmentTT,
    FragmentTy,
    FragmentVis,
}
use TokenDescription::*;
#[derive(Clone, Debug)]
pub struct RustParser<Span: 'static> {
    buffer: TokenBuffer<Span>,
    stack: Vec<State<Span>>,
    tried: SmallVec<[TokenDescription; 10]>,
}
impl<Span> PartialEq for RustParser<Span> {
    fn eq(&self, other: &RustParser<Span>) -> bool {
        std::ptr::eq(self, other) || (self.buffer == other.buffer && self.stack == other.stack)
    }
}
impl<Span> Hash for RustParser<Span>
where
    Span: 'static,
{
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.buffer.hash(state);
        self.stack.hash(state);
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TransitionData {
    pub popped: usize,
    pub buf_size: usize,
    pub pushed: Vec<&'static str>,
}
impl<Span> RustParser<Span>
where
    Span: Copy + 'static,
{
    pub fn item() -> RustParser<Span> {
        RustParser {
            buffer: TokenBuffer::Empty([]),
            stack: vec![(item, concat!("<", stringify!(item), " entry point>"))],
            tried: SmallVec::new(),
        }
    }

    pub fn ty() -> RustParser<Span> {
        RustParser {
            buffer: TokenBuffer::Empty([]),
            stack: vec![(ty, concat!("<", stringify!(ty), " entry point>"))],
            tried: SmallVec::new(),
        }
    }

    pub fn expr() -> RustParser<Span> {
        RustParser {
            buffer: TokenBuffer::Empty([]),
            stack: vec![(expr, concat!("<", stringify!(expr), " entry point>"))],
            tried: SmallVec::new(),
        }
    }

    pub fn step(
        &mut self,
        token: TokenDescription,
        span: Span,
    ) -> Result<TransitionData, (Span, Vec<TokenDescription>)> {
        match self.buffer.len() {
            buf_size @ (0 | 1) => {
                self.buffer.push(token, span);
                return Ok(TransitionData {
                    popped: 0,
                    buf_size,
                    pushed: vec![],
                });
            }
            2 => {
                self.buffer.push(token, span);
            }
            _ => panic!("Token buffer is full!"),
        };
        self.perform_progress().map_err(|e| match e {
            ProgressError::EmptyStack(s) => (s.unwrap(), vec![]),
            ProgressError::ParsingError(s, expected) => (s.unwrap(), expected),
        })
    }

    pub fn finish(&mut self) -> Result<(), Option<(Span, Vec<TokenDescription>)>> {
        while !self.buffer.is_empty() {
            match self.perform_progress() {
                Ok(_) => continue,
                Err(ProgressError::EmptyStack(s)) => {
                    let e = s.map(|s| (s, vec![]));
                    return Err(e);
                }
                Err(ProgressError::ParsingError(s, e)) => {
                    return Err(s.map(|s| (s, e)));
                }
            }
        }
        while !self.stack.is_empty() {
            match self.perform_progress() {
                Ok(_) => continue,
                Err(ProgressError::EmptyStack(_)) => break,
                Err(ProgressError::ParsingError(s, e)) => {
                    let e = s.map(|s| (s, e));
                    return Err(e);
                }
            }
        }
        Ok(())
    }

    fn perform_progress(&mut self) -> Result<TransitionData, ProgressError<Span>> {
        let mut trans = TransitionData::new_full_buffer();
        self.tried.clear();
        let mut fuel = u8::MAX;
        loop {
            assert!(
                fuel != 0,
                "Out of fuel. This is probably a bug in the parser codegen."
            );
            fuel -= 1;
            trans.log_pop();
            let (state, name) = self.stack.pop().ok_or_else(|| {
                let s = self.buffer.peek().map(|(_, s)| s);
                ProgressError::EmptyStack(s)
            })?;
            match state(self)
                .map_err(|s| ProgressError::ParsingError(s, self.tried.clone().into_vec()))?
            {
                Transition::CallNow(states) => {
                    states.iter().for_each(|(_, fn_)| trans.log_push(fn_));
                    self.stack.extend(states.iter().copied());
                }
                Transition::CallThen(states) => {
                    self.buffer.shift();
                    states.iter().for_each(|(_, fn_)| trans.log_push(fn_));
                    self.stack.extend(states.iter().copied());
                    break Ok(trans);
                }
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
enum ProgressError<Span> {
    EmptyStack(Option<Span>),
    ParsingError(Option<Span>, Vec<TokenDescription>),
}
#[derive(Clone, Debug)]
enum TokenBuffer<Span> {
    Empty([(TokenDescription, Span); 0]),
    Single([(TokenDescription, Span); 1]),
    Double([(TokenDescription, Span); 2]),
    Triple([(TokenDescription, Span); 3]),
}
impl<Span> Hash for TokenBuffer<Span> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        let discriminant = mem::discriminant(self);
        discriminant.hash(state);
        match self {
            TokenBuffer::Empty([]) => <[TokenDescription; 0] as Hash>::hash(&[], state),
            TokenBuffer::Single([(a, _)]) => [a].hash(state),
            TokenBuffer::Double([(a, _), (b, _)]) => [a, b].hash(state),
            TokenBuffer::Triple([(a, _), (b, _), (c, _)]) => [a, b, c].hash(state),
        }
    }
}
impl<Span> PartialEq for TokenBuffer<Span> {
    fn eq(&self, other: &TokenBuffer<Span>) -> bool {
        let self_tag = mem::discriminant(self);
        let arg1_tag = mem::discriminant(other);
        self_tag == arg1_tag
            && match (self, other) {
                (TokenBuffer::Empty([]), TokenBuffer::Empty([])) => true,
                (TokenBuffer::Single([(a, _)]), TokenBuffer::Single([(a_, _)])) => [a] == [a_],
                (
                    TokenBuffer::Double([(a, _), (b, _)]),
                    TokenBuffer::Double([(a_, _), (b_, _)]),
                ) => [a, b] == [a_, b_],
                (
                    TokenBuffer::Triple([(a, _), (b, _), (c, _)]),
                    TokenBuffer::Triple([(a_, _), (b_, _), (c_, _)]),
                ) => [a, b, c] == [a_, b_, c_],
                _ => unreachable!(),
            }
    }
}
impl<Span> Eq for TokenBuffer<Span> {}
type State<Span> = (
    fn(&mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>>,
    &'static str,
);
#[derive(Clone, Copy, Debug, PartialEq)]
enum Transition<Span: 'static> {
    CallNow(&'static [State<Span>]),
    CallThen(&'static [State<Span>]),
}
impl<Span> TokenBuffer<Span>
where
    Span: Copy + 'static,
{
    fn len(&self) -> usize {
        match self {
            TokenBuffer::Empty(_) => 0,
            TokenBuffer::Single(_) => 1,
            TokenBuffer::Double(_) => 2,
            TokenBuffer::Triple(_) => 3,
        }
    }

    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    fn push(&mut self, token: TokenDescription, span: Span) {
        match self {
            TokenBuffer::Empty([]) => {
                *self = TokenBuffer::Single([(token, span)]);
            }
            TokenBuffer::Single([a]) => {
                *self = TokenBuffer::Double([*a, (token, span)]);
            }
            TokenBuffer::Double([a, b]) => {
                *self = TokenBuffer::Triple([*a, *b, (token, span)]);
            }
            TokenBuffer::Triple([a, b, c]) => {
                panic!("Token buffer is full!");
            }
        }
    }

    fn shift(&mut self) -> (TokenDescription, Span) {
        match self {
            TokenBuffer::Empty(_) => panic!("Token buffer is empty!!"),
            TokenBuffer::Single([a]) => {
                let a = *a;
                *self = TokenBuffer::Empty([]);
                a
            }
            TokenBuffer::Double([a, b]) => {
                let a = *a;
                *self = TokenBuffer::Single([*b]);
                a
            }
            TokenBuffer::Triple([a, b, c]) => {
                let a = *a;
                *self = TokenBuffer::Double([*b, *c]);
                a
            }
        }
    }

    fn peek(&self) -> Option<(TokenDescription, Span)> {
        match self {
            TokenBuffer::Empty(_) => None,
            TokenBuffer::Single([a])
            | TokenBuffer::Double([a, _])
            | TokenBuffer::Triple([a, _, _]) => Some(*a),
        }
    }

    fn peek2(&self) -> Option<(TokenDescription, Span)> {
        match self {
            TokenBuffer::Empty(_) | TokenBuffer::Single([_]) => None,
            TokenBuffer::Double([_, a]) | TokenBuffer::Triple([_, a, _]) => Some(*a),
        }
    }

    fn peek3(&self) -> Option<(TokenDescription, Span)> {
        match self {
            TokenBuffer::Empty(_) | TokenBuffer::Single([_]) | TokenBuffer::Double([_, _]) => None,
            TokenBuffer::Triple([_, _, a]) => Some(*a),
        }
    }
}
impl TransitionData {
    pub fn empty() -> TransitionData {
        TransitionData {
            popped: 0,
            buf_size: 0,
            pushed: vec![],
        }
    }

    pub fn combine_chasles(mut self, other: TransitionData) -> TransitionData {
        for _ in 0..other.popped {
            self.log_pop();
        }
        for pushed in other.pushed {
            self.log_push(pushed);
        }
        self
    }

    fn new_full_buffer() -> TransitionData {
        TransitionData {
            popped: 0,
            buf_size: 3,
            pushed: vec![],
        }
    }

    fn log_pop(&mut self) {
        if self.pushed.pop().is_none() {
            self.popped += 1;
        }
    }

    fn log_push(&mut self, state: &'static str) {
        self.pushed.push(state);
    }
}
macro_rules ! call_now { ($ _input : expr $ (, $ arg : expr) * $ (,) ?) => { return Ok ({ Transition :: CallNow (& [$ (($ arg , stringify ! ($ arg))) , *]) }) } ; }
macro_rules ! call_then { ($ input : expr $ (, $ arg : expr) * $ (,) ?) => { Ok ({ Transition :: CallThen (& [$ (($ arg , stringify ! ($ arg))) , *]) }) } ; }
macro_rules ! nothing { [$ _input : expr] => { Ok (Transition :: CallNow (& [])) } ; }
macro_rules! bump {
    ($input:expr) => {{ !$input.buffer.is_empty() }};
    ($input:expr, $token:expr) => {{
        $input.tried.push($token);
        $input
            .buffer
            .peek()
            .map(|(k, _)| k == $token)
            .unwrap_or_default()
    }};
}
macro_rules! error {
    ($input:expr) => {{
        return Err($input.buffer.peek().map(|(_, span)| span));
    }};
}
macro_rules! end {
    ($input:expr) => {{
        return Ok(Transition::CallNow(&[]));
    }};
}
macro_rules! cond {
    ($input:expr, $method:ident) => {{ !$input.buffer.is_empty() }};
    ($input:expr,peek, $expected:expr) => {{
        $input.tried.push($expected);
        $input
            .buffer
            .peek()
            .map(|(k, _)| k == $expected)
            .unwrap_or_default()
    }};
    ($input:expr, $method:ident, $expected:expr) => {{
        $input
            .buffer
            .$method()
            .map(|(k, _)| k == $expected)
            .unwrap_or_default()
    }};
}
fn vis_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LParen] {
        call_now![input, vis_5]
    } else {
        call_now![input,]
    }
}
fn vis_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Crate] {
        call_now![input, vis_2]
    } else {
        call_now![input,]
    }
}
fn vis_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn vis_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn vis_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis_0, vis_1]
}
fn vis_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn vis_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis_3, vis_4]
}
fn vis_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Pub] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn vis_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis_6, vis_7]
}
fn vis<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis_8]
}
fn item_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Fn] {
        call_now![input, item_1]
    } else {
        call_now![input, item_3]
    }
}
fn item_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item]
}
fn item_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_0]
}
fn item_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn item_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_2]
}
fn item_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Pub] {
        call_now![input, item_6]
    } else {
        call_now![input,]
    }
}
fn item_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis]
}
fn item_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_5]
}
fn item_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_4, item_7]
}
fn item<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_8]
}
fn fn_item_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block]
}
fn fn_item_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RightArrow] {
        call_now![input, fn_item_3]
    } else {
        call_now![input,]
    }
}
fn fn_item_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty]
}
fn fn_item_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_item_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_1, fn_item_2]
}
fn fn_item_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args]
}
fn fn_item_13<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, fn_item_7]
    } else {
        call_now![input, fn_item_12]
    }
}
fn fn_item_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Ident] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_item_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_6]
}
fn fn_item_12<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, fn_item_9]
    } else {
        call_now![input, fn_item_11]
    }
}
fn fn_item_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentIdent] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_item_9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_8]
}
fn fn_item_10<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn fn_item_11<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_10]
}
fn fn_item_14<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Fn] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_item_15<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input, fn_item_0, fn_item_4, fn_item_5, fn_item_13, fn_item_14
    ]
}
fn fn_item<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_15]
}
fn block_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBrace] {
        call_now![input, block_1]
    } else {
        call_now![input, block_4]
    }
}
fn block_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBrace] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_0]
}
fn block_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_]
}
fn block_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner]
}
fn block_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_2, block_3]
}
fn block_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LBrace] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_5, block_6]
}
fn block<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_7]
}
fn block__11<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBrace] {
        call_now![input, block__1]
    } else {
        call_now![input, block__10]
    }
}
fn block__0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBrace] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block__1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__0]
}
fn block__10<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Semicolon] {
        call_now![input, block__9]
    } else {
        call_now![input,]
    }
}
fn block__7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBrace] {
        call_now![input, block__3]
    } else {
        call_now![input, block__6]
    }
}
fn block__2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBrace] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block__3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__2]
}
fn block__4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_]
}
fn block__5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner]
}
fn block__6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__4, block__5]
}
fn block__8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Semicolon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block__9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__7, block__8]
}
fn block__12<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__11]
}
fn block_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__12]
}
fn stmt_inner_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn stmt_inner_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Let] {
        call_now![input, stmt_inner_4]
    } else {
        call_now![input,]
    }
}
fn stmt_inner_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Equals] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn stmt_inner_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat]
}
fn stmt_inner_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Let] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn stmt_inner_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner_1, stmt_inner_2, stmt_inner_3]
}
fn stmt_inner_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner_0, stmt_inner_5]
}
fn stmt_inner<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner_6]
}
fn ty_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, ty_1]
    } else {
        call_now![input, ty_6]
    }
}
fn ty_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn ty_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_0]
}
fn ty_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentTy] {
        call_now![input, ty_3]
    } else {
        call_now![input, ty_5]
    }
}
fn ty_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn ty_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_2]
}
fn ty_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn ty_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_4]
}
fn ty_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_7]
}
fn ty<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_8]
}
fn fn_args_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, fn_args_1]
    } else {
        call_now![input, fn_args_3]
    }
}
fn fn_args_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_0]
}
fn fn_args_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_]
}
fn fn_args_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_2]
}
fn fn_args_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, fn_args_6]
    } else {
        call_now![input,]
    }
}
fn fn_args_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_5]
}
fn fn_args_11<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, fn_args_8]
    } else {
        call_now![input, fn_args_10]
    }
}
fn fn_args_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input,]
}
fn fn_args_9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_arg]
}
fn fn_args_10<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_9]
}
fn fn_args_12<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args_13<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_4, fn_args_7, fn_args_11, fn_args_12]
}
fn fn_args<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_13]
}
fn fn_args__2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, fn_args__1]
    } else {
        call_now![input,]
    }
}
fn fn_args__0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args__1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args__0]
}
fn fn_args__5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, fn_args__4]
    } else {
        call_now![input,]
    }
}
fn fn_args__3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args__4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args__3]
}
fn fn_args__6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_arg]
}
fn fn_args__7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args__2, fn_args__5, fn_args__6]
}
fn fn_args_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args__7]
}
fn pat_10<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, pat_1]
    } else {
        call_now![input, pat_9]
    }
}
fn pat_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn pat_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_0]
}
fn pat_9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, pat_3]
    } else {
        call_now![input, pat_8]
    }
}
fn pat_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn pat_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_2]
}
fn pat_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentPat] {
        call_now![input, pat_5]
    } else {
        call_now![input, pat_7]
    }
}
fn pat_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn pat_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_4]
}
fn pat_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn pat_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_6]
}
fn pat_11<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_10]
}
fn pat<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_11]
}
fn fn_arg_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty]
}
fn fn_arg_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Colon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_arg_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat]
}
fn fn_arg_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_arg_0, fn_arg_1, fn_arg_2]
}
fn fn_arg<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_arg_3]
}
fn expr_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom]
}
fn expr_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_prefixed_unary_op]
}
fn expr_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_0, expr_1, expr_2]
}
fn expr<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_3]
}
fn expr_after_atom_87<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Plus] {
        call_now![input, expr_after_atom_2]
    } else {
        call_now![input, expr_after_atom_86]
    }
}
fn expr_after_atom_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_0, expr_after_atom_1]
}
fn expr_after_atom_86<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Minus] {
        call_now![input, expr_after_atom_5]
    } else {
        call_now![input, expr_after_atom_85]
    }
}
fn expr_after_atom_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_3, expr_after_atom_4]
}
fn expr_after_atom_85<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Star] {
        call_now![input, expr_after_atom_8]
    } else {
        call_now![input, expr_after_atom_84]
    }
}
fn expr_after_atom_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_6, expr_after_atom_7]
}
fn expr_after_atom_84<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Slash] {
        call_now![input, expr_after_atom_11]
    } else {
        call_now![input, expr_after_atom_83]
    }
}
fn expr_after_atom_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_9, expr_after_atom_10]
}
fn expr_after_atom_83<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Percent] {
        call_now![input, expr_after_atom_14]
    } else {
        call_now![input, expr_after_atom_82]
    }
}
fn expr_after_atom_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_12, expr_after_atom_13]
}
fn expr_after_atom_82<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Caret] {
        call_now![input, expr_after_atom_17]
    } else {
        call_now![input, expr_after_atom_81]
    }
}
fn expr_after_atom_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_15, expr_after_atom_16]
}
fn expr_after_atom_81<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, And] {
        call_now![input, expr_after_atom_20]
    } else {
        call_now![input, expr_after_atom_80]
    }
}
fn expr_after_atom_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_18, expr_after_atom_19]
}
fn expr_after_atom_80<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Or] {
        call_now![input, expr_after_atom_23]
    } else {
        call_now![input, expr_after_atom_79]
    }
}
fn expr_after_atom_21<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_22<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_23<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_21, expr_after_atom_22]
}
fn expr_after_atom_79<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, AndAnd] {
        call_now![input, expr_after_atom_26]
    } else {
        call_now![input, expr_after_atom_78]
    }
}
fn expr_after_atom_24<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_25<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_26<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_24, expr_after_atom_25]
}
fn expr_after_atom_78<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, OrOr] {
        call_now![input, expr_after_atom_29]
    } else {
        call_now![input, expr_after_atom_77]
    }
}
fn expr_after_atom_27<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_28<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_29<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_27, expr_after_atom_28]
}
fn expr_after_atom_77<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Shl] {
        call_now![input, expr_after_atom_32]
    } else {
        call_now![input, expr_after_atom_76]
    }
}
fn expr_after_atom_30<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_31<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_32<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_30, expr_after_atom_31]
}
fn expr_after_atom_76<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Shr] {
        call_now![input, expr_after_atom_35]
    } else {
        call_now![input, expr_after_atom_75]
    }
}
fn expr_after_atom_33<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_34<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_35<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_33, expr_after_atom_34]
}
fn expr_after_atom_75<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, EqualsEquals] {
        call_now![input, expr_after_atom_38]
    } else {
        call_now![input, expr_after_atom_74]
    }
}
fn expr_after_atom_36<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_37<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_38<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_36, expr_after_atom_37]
}
fn expr_after_atom_74<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, NotEquals] {
        call_now![input, expr_after_atom_41]
    } else {
        call_now![input, expr_after_atom_73]
    }
}
fn expr_after_atom_39<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_40<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_41<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_39, expr_after_atom_40]
}
fn expr_after_atom_73<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, GreaterThan] {
        call_now![input, expr_after_atom_44]
    } else {
        call_now![input, expr_after_atom_72]
    }
}
fn expr_after_atom_42<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_43<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_44<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_42, expr_after_atom_43]
}
fn expr_after_atom_72<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LessThan] {
        call_now![input, expr_after_atom_47]
    } else {
        call_now![input, expr_after_atom_71]
    }
}
fn expr_after_atom_45<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_46<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_47<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_45, expr_after_atom_46]
}
fn expr_after_atom_71<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, GreaterThanEquals] {
        call_now![input, expr_after_atom_50]
    } else {
        call_now![input, expr_after_atom_70]
    }
}
fn expr_after_atom_48<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_49<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_50<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_48, expr_after_atom_49]
}
fn expr_after_atom_70<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LessThanEquals] {
        call_now![input, expr_after_atom_53]
    } else {
        call_now![input, expr_after_atom_69]
    }
}
fn expr_after_atom_51<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_52<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_53<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_51, expr_after_atom_52]
}
fn expr_after_atom_69<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, DotDot] {
        call_now![input, expr_after_atom_56]
    } else {
        call_now![input, expr_after_atom_68]
    }
}
fn expr_after_atom_54<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_55<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_56<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_54, expr_after_atom_55]
}
fn expr_after_atom_68<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, DotDotEquals] {
        call_now![input, expr_after_atom_59]
    } else {
        call_now![input, expr_after_atom_67]
    }
}
fn expr_after_atom_57<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_58<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_59<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_57, expr_after_atom_58]
}
fn expr_after_atom_67<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LParen] {
        call_now![input, expr_after_atom_62]
    } else {
        call_now![input, expr_after_atom_66]
    }
}
fn expr_after_atom_60<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom]
}
fn expr_after_atom_61<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call]
}
fn expr_after_atom_62<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_60, expr_after_atom_61]
}
fn expr_after_atom_66<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Dot] {
        call_now![input, expr_after_atom_65]
    } else {
        call_now![input,]
    }
}
fn expr_after_atom_63<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom]
}
fn expr_after_atom_64<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr]
}
fn expr_after_atom_65<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_63, expr_after_atom_64]
}
fn expr_after_atom_88<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_87]
}
fn expr_after_atom<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_88]
}
fn expr_atom_28<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Return] {
        call_now![input, expr_atom_1]
    } else {
        call_now![input, expr_atom_27]
    }
}
fn expr_atom_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break]
}
fn expr_atom_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_0]
}
fn expr_atom_27<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Break] {
        call_now![input, expr_atom_3]
    } else {
        call_now![input, expr_atom_26]
    }
}
fn expr_atom_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break]
}
fn expr_atom_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_2]
}
fn expr_atom_26<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, expr_atom_5]
    } else {
        call_now![input, expr_atom_25]
    }
}
fn expr_atom_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_ident]
}
fn expr_atom_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_4]
}
fn expr_atom_25<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, expr_atom_7]
    } else {
        call_now![input, expr_atom_24]
    }
}
fn expr_atom_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_atom_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_6]
}
fn expr_atom_24<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentExpr] {
        call_now![input, expr_atom_9]
    } else {
        call_now![input, expr_atom_23]
    }
}
fn expr_atom_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_atom_9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_8]
}
fn expr_atom_23<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Literal] {
        call_now![input, expr_atom_11]
    } else {
        call_now![input, expr_atom_22]
    }
}
fn expr_atom_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_atom_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_10]
}
fn expr_atom_22<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, If] {
        call_now![input, expr_atom_13]
    } else {
        call_now![input, expr_atom_21]
    }
}
fn expr_atom_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_if]
}
fn expr_atom_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_12]
}
fn expr_atom_21<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LBracket] {
        call_now![input, expr_atom_15]
    } else {
        call_now![input, expr_atom_20]
    }
}
fn expr_atom_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array]
}
fn expr_atom_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_14]
}
fn expr_atom_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LBrace] {
        call_now![input, expr_atom_17]
    } else {
        call_now![input, expr_atom_19]
    }
}
fn expr_atom_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block]
}
fn expr_atom_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_16]
}
fn expr_atom_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn expr_atom_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_18]
}
fn expr_atom_29<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_28]
}
fn expr_atom<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_29]
}
fn expr_return_or_break_98<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Async] {
        call_now![input, expr_return_or_break_1]
    } else {
        call_now![input, expr_return_or_break_97]
    }
}
fn expr_return_or_break_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_0]
}
fn expr_return_or_break_97<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Break] {
        call_now![input, expr_return_or_break_3]
    } else {
        call_now![input, expr_return_or_break_96]
    }
}
fn expr_return_or_break_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_2]
}
fn expr_return_or_break_96<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Continue] {
        call_now![input, expr_return_or_break_5]
    } else {
        call_now![input, expr_return_or_break_95]
    }
}
fn expr_return_or_break_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_4]
}
fn expr_return_or_break_95<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Crate] {
        call_now![input, expr_return_or_break_7]
    } else {
        call_now![input, expr_return_or_break_94]
    }
}
fn expr_return_or_break_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_6]
}
fn expr_return_or_break_94<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, False] {
        call_now![input, expr_return_or_break_9]
    } else {
        call_now![input, expr_return_or_break_93]
    }
}
fn expr_return_or_break_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_8]
}
fn expr_return_or_break_93<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, For] {
        call_now![input, expr_return_or_break_11]
    } else {
        call_now![input, expr_return_or_break_92]
    }
}
fn expr_return_or_break_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_10]
}
fn expr_return_or_break_92<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Let] {
        call_now![input, expr_return_or_break_13]
    } else {
        call_now![input, expr_return_or_break_91]
    }
}
fn expr_return_or_break_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_12]
}
fn expr_return_or_break_91<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Loop] {
        call_now![input, expr_return_or_break_15]
    } else {
        call_now![input, expr_return_or_break_90]
    }
}
fn expr_return_or_break_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_14]
}
fn expr_return_or_break_90<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Match] {
        call_now![input, expr_return_or_break_17]
    } else {
        call_now![input, expr_return_or_break_89]
    }
}
fn expr_return_or_break_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_16]
}
fn expr_return_or_break_89<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Move] {
        call_now![input, expr_return_or_break_19]
    } else {
        call_now![input, expr_return_or_break_88]
    }
}
fn expr_return_or_break_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_18]
}
fn expr_return_or_break_88<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Return] {
        call_now![input, expr_return_or_break_21]
    } else {
        call_now![input, expr_return_or_break_87]
    }
}
fn expr_return_or_break_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_21<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_20]
}
fn expr_return_or_break_87<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Self_] {
        call_now![input, expr_return_or_break_23]
    } else {
        call_now![input, expr_return_or_break_86]
    }
}
fn expr_return_or_break_22<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_23<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_22]
}
fn expr_return_or_break_86<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, SelfUpper] {
        call_now![input, expr_return_or_break_25]
    } else {
        call_now![input, expr_return_or_break_85]
    }
}
fn expr_return_or_break_24<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_25<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_24]
}
fn expr_return_or_break_85<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, True] {
        call_now![input, expr_return_or_break_27]
    } else {
        call_now![input, expr_return_or_break_84]
    }
}
fn expr_return_or_break_26<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_27<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_26]
}
fn expr_return_or_break_84<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Union] {
        call_now![input, expr_return_or_break_29]
    } else {
        call_now![input, expr_return_or_break_83]
    }
}
fn expr_return_or_break_28<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_29<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_28]
}
fn expr_return_or_break_83<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, While] {
        call_now![input, expr_return_or_break_31]
    } else {
        call_now![input, expr_return_or_break_82]
    }
}
fn expr_return_or_break_30<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_31<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_30]
}
fn expr_return_or_break_82<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Yield] {
        call_now![input, expr_return_or_break_33]
    } else {
        call_now![input, expr_return_or_break_81]
    }
}
fn expr_return_or_break_32<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_33<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_32]
}
fn expr_return_or_break_81<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, expr_return_or_break_35]
    } else {
        call_now![input, expr_return_or_break_80]
    }
}
fn expr_return_or_break_34<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_35<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_34]
}
fn expr_return_or_break_80<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, expr_return_or_break_37]
    } else {
        call_now![input, expr_return_or_break_79]
    }
}
fn expr_return_or_break_36<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_37<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_36]
}
fn expr_return_or_break_79<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LParen] {
        call_now![input, expr_return_or_break_39]
    } else {
        call_now![input, expr_return_or_break_78]
    }
}
fn expr_return_or_break_38<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_39<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_38]
}
fn expr_return_or_break_78<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LBracket] {
        call_now![input, expr_return_or_break_41]
    } else {
        call_now![input, expr_return_or_break_77]
    }
}
fn expr_return_or_break_40<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_41<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_40]
}
fn expr_return_or_break_77<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LBrace] {
        call_now![input, expr_return_or_break_43]
    } else {
        call_now![input, expr_return_or_break_76]
    }
}
fn expr_return_or_break_42<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_43<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_42]
}
fn expr_return_or_break_76<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Literal] {
        call_now![input, expr_return_or_break_45]
    } else {
        call_now![input, expr_return_or_break_75]
    }
}
fn expr_return_or_break_44<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_45<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_44]
}
fn expr_return_or_break_75<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentLiteral] {
        call_now![input, expr_return_or_break_47]
    } else {
        call_now![input, expr_return_or_break_74]
    }
}
fn expr_return_or_break_46<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_47<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_46]
}
fn expr_return_or_break_74<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Not] {
        call_now![input, expr_return_or_break_49]
    } else {
        call_now![input, expr_return_or_break_73]
    }
}
fn expr_return_or_break_48<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_49<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_48]
}
fn expr_return_or_break_73<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Star] {
        call_now![input, expr_return_or_break_51]
    } else {
        call_now![input, expr_return_or_break_72]
    }
}
fn expr_return_or_break_50<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_51<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_50]
}
fn expr_return_or_break_72<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Or] {
        call_now![input, expr_return_or_break_53]
    } else {
        call_now![input, expr_return_or_break_71]
    }
}
fn expr_return_or_break_52<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_53<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_52]
}
fn expr_return_or_break_71<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, And] {
        call_now![input, expr_return_or_break_55]
    } else {
        call_now![input, expr_return_or_break_70]
    }
}
fn expr_return_or_break_54<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_55<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_54]
}
fn expr_return_or_break_70<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, DotDot] {
        call_now![input, expr_return_or_break_57]
    } else {
        call_now![input, expr_return_or_break_69]
    }
}
fn expr_return_or_break_56<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_57<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_56]
}
fn expr_return_or_break_69<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LessThan] {
        call_now![input, expr_return_or_break_59]
    } else {
        call_now![input, expr_return_or_break_68]
    }
}
fn expr_return_or_break_58<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_59<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_58]
}
fn expr_return_or_break_68<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, ColonColon] {
        call_now![input, expr_return_or_break_61]
    } else {
        call_now![input, expr_return_or_break_67]
    }
}
fn expr_return_or_break_60<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_61<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_60]
}
fn expr_return_or_break_67<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Pound] {
        call_now![input, expr_return_or_break_63]
    } else {
        call_now![input, expr_return_or_break_66]
    }
}
fn expr_return_or_break_62<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_63<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_62]
}
fn expr_return_or_break_66<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentExpr] {
        call_now![input, expr_return_or_break_65]
    } else {
        call_now![input,]
    }
}
fn expr_return_or_break_64<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_65<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_64]
}
fn expr_return_or_break_106<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Return] {
        call_now![input, expr_return_or_break_100]
    } else {
        call_now![input, expr_return_or_break_105]
    }
}
fn expr_return_or_break_99<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Return] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_return_or_break_100<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_99]
}
fn expr_return_or_break_105<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Break] {
        call_now![input, expr_return_or_break_102]
    } else {
        call_now![input, expr_return_or_break_104]
    }
}
fn expr_return_or_break_101<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Break] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_return_or_break_102<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_101]
}
fn expr_return_or_break_103<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn expr_return_or_break_104<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_103]
}
fn expr_return_or_break_107<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_98, expr_return_or_break_106]
}
fn expr_return_or_break<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_107]
}
fn expr_ident_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, ColonColon] {
        call_now![input, expr_ident_2]
    } else {
        call_now![input,]
    }
}
fn expr_ident_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments]
}
fn expr_ident_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, ColonColon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_ident_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_ident_0, expr_ident_1]
}
fn expr_ident_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Ident] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_ident_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_ident_3, expr_ident_4]
}
fn expr_ident<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_ident_5]
}
fn expr_if_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Else] {
        call_now![input, expr_if_2]
    } else {
        call_now![input,]
    }
}
fn expr_if_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_block]
}
fn expr_if_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Else] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_if_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_if_0, expr_if_1]
}
fn expr_if_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_block]
}
fn expr_if_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_if_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, If] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_if_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_if_3, expr_if_4, expr_if_5, expr_if_6]
}
fn expr_if<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_if_7]
}
fn expr_array_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBracket] {
        call_now![input, expr_array_1]
    } else {
        call_now![input, expr_array_10]
    }
}
fn expr_array_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_0]
}
fn expr_array_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Semicolon] {
        call_now![input, expr_array_5]
    } else {
        call_now![input, expr_array_7]
    }
}
fn expr_array_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_array_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Semicolon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_2, expr_array_3, expr_array_4]
}
fn expr_array_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_]
}
fn expr_array_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_6]
}
fn expr_array_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_array_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_8, expr_array_9]
}
fn expr_array_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_11, expr_array_12]
}
fn expr_array<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_13]
}
fn expr_array__10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, expr_array__7]
    } else {
        call_now![input, expr_array__9]
    }
}
fn expr_array__5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBracket] {
        call_now![input, expr_array__1]
    } else {
        call_now![input, expr_array__4]
    }
}
fn expr_array__0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array__1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__0]
}
fn expr_array__2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_]
}
fn expr_array__3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_array__4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__2, expr_array__3]
}
fn expr_array__6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array__7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__5, expr_array__6]
}
fn expr_array__8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array__9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__8]
}
fn expr_array__11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__10]
}
fn expr_array_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__11]
}
fn expr_block_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block]
}
fn expr_block_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_block_0]
}
fn expr_block<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_block_1]
}
fn expr_call_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, expr_call_1]
    } else {
        call_now![input, expr_call_4]
    }
}
fn expr_call_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_0]
}
fn expr_call_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_]
}
fn expr_call_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_call_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_2, expr_call_3]
}
fn expr_call_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_5, expr_call_6]
}
fn expr_call<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_7]
}
fn expr_call__10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, expr_call__7]
    } else {
        call_now![input, expr_call__9]
    }
}
fn expr_call__5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, expr_call__1]
    } else {
        call_now![input, expr_call__4]
    }
}
fn expr_call__0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call__1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__0]
}
fn expr_call__2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_]
}
fn expr_call__3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_call__4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__2, expr_call__3]
}
fn expr_call__6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call__7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__5, expr_call__6]
}
fn expr_call__8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call__9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__8]
}
fn expr_call__11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__10]
}
fn expr_call_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__11]
}
fn expr_dot_expr_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Await] {
        call_now![input, expr_dot_expr_1]
    } else {
        call_now![input, expr_dot_expr_19]
    }
}
fn expr_dot_expr_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Await] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_0]
}
fn expr_dot_expr_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, expr_dot_expr_4]
    } else {
        call_now![input, expr_dot_expr_18]
    }
}
fn expr_dot_expr_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method]
}
fn expr_dot_expr_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Ident] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_2, expr_dot_expr_3]
}
fn expr_dot_expr_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, expr_dot_expr_7]
    } else {
        call_now![input, expr_dot_expr_17]
    }
}
fn expr_dot_expr_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method]
}
fn expr_dot_expr_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentIdent] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_5, expr_dot_expr_6]
}
fn expr_dot_expr_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Literal] {
        call_now![input, expr_dot_expr_10]
    } else {
        call_now![input, expr_dot_expr_16]
    }
}
fn expr_dot_expr_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method]
}
fn expr_dot_expr_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Literal] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_8, expr_dot_expr_9]
}
fn expr_dot_expr_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentLiteral] {
        call_now![input, expr_dot_expr_13]
    } else {
        call_now![input, expr_dot_expr_15]
    }
}
fn expr_dot_expr_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method]
}
fn expr_dot_expr_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentLiteral] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_11, expr_dot_expr_12]
}
fn expr_dot_expr_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn expr_dot_expr_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_14]
}
fn expr_dot_expr_21<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Dot] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_22<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_20, expr_dot_expr_21]
}
fn expr_dot_expr<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_22]
}
fn expr_field_or_method_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LParen] {
        call_now![input, expr_field_or_method_1]
    } else {
        call_now![input,]
    }
}
fn expr_field_or_method_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call]
}
fn expr_field_or_method_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method_0]
}
fn expr_field_or_method_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, ColonColon] {
        call_now![input, expr_field_or_method_6]
    } else {
        call_now![input,]
    }
}
fn expr_field_or_method_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call]
}
fn expr_field_or_method_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments]
}
fn expr_field_or_method_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, ColonColon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_field_or_method_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_field_or_method_3,
        expr_field_or_method_4,
        expr_field_or_method_5
    ]
}
fn expr_field_or_method_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method_2, expr_field_or_method_7]
}
fn expr_field_or_method<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method_8]
}
fn expr_angle_bracketed_generic_arguments_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, GreaterThan] {
        call_now![input, expr_angle_bracketed_generic_arguments_1]
    } else {
        call_now![input, expr_angle_bracketed_generic_arguments_4]
    }
}
fn expr_angle_bracketed_generic_arguments_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, GreaterThan] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments_0]
}
fn expr_angle_bracketed_generic_arguments_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments_]
}
fn expr_angle_bracketed_generic_arguments_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument]
}
fn expr_angle_bracketed_generic_arguments_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_angle_bracketed_generic_arguments_2,
        expr_angle_bracketed_generic_arguments_3
    ]
}
fn expr_angle_bracketed_generic_arguments_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LessThan] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_angle_bracketed_generic_arguments_5,
        expr_angle_bracketed_generic_arguments_6
    ]
}
fn expr_angle_bracketed_generic_arguments<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments_7]
}
fn expr_angle_bracketed_generic_arguments__11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, GreaterThan] {
        call_now![input, expr_angle_bracketed_generic_arguments__1]
    } else {
        call_now![input, expr_angle_bracketed_generic_arguments__10]
    }
}
fn expr_angle_bracketed_generic_arguments__0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, GreaterThan] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments__1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments__0]
}
fn expr_angle_bracketed_generic_arguments__10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, expr_angle_bracketed_generic_arguments__9]
    } else {
        call_now![input,]
    }
}
fn expr_angle_bracketed_generic_arguments__7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, GreaterThan] {
        call_now![input, expr_angle_bracketed_generic_arguments__3]
    } else {
        call_now![input, expr_angle_bracketed_generic_arguments__6]
    }
}
fn expr_angle_bracketed_generic_arguments__2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, GreaterThan] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments__3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments__2]
}
fn expr_angle_bracketed_generic_arguments__4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments_]
}
fn expr_angle_bracketed_generic_arguments__5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument]
}
fn expr_angle_bracketed_generic_arguments__6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_angle_bracketed_generic_arguments__4,
        expr_angle_bracketed_generic_arguments__5
    ]
}
fn expr_angle_bracketed_generic_arguments__8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments__9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_angle_bracketed_generic_arguments__7,
        expr_angle_bracketed_generic_arguments__8
    ]
}
fn expr_angle_bracketed_generic_arguments__12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments__11]
}
fn expr_angle_bracketed_generic_arguments_<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments__12]
}
fn expr_generic_argument_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Literal] {
        call_now![input, expr_generic_argument_1]
    } else {
        call_now![input, expr_generic_argument_18]
    }
}
fn expr_generic_argument_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Literal] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_generic_argument_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_0]
}
fn expr_generic_argument_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentLiteral] {
        call_now![input, expr_generic_argument_3]
    } else {
        call_now![input, expr_generic_argument_17]
    }
}
fn expr_generic_argument_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentLiteral] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_generic_argument_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_2]
}
fn expr_generic_argument_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, expr_generic_argument_5]
    } else {
        call_now![input, expr_generic_argument_16]
    }
}
fn expr_generic_argument_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Ident] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_generic_argument_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_4]
}
fn expr_generic_argument_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, expr_generic_argument_7]
    } else {
        call_now![input, expr_generic_argument_15]
    }
}
fn expr_generic_argument_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentIdent] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_generic_argument_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_6]
}
fn expr_generic_argument_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LBrace] {
        call_now![input, expr_generic_argument_9]
    } else {
        call_now![input, expr_generic_argument_14]
    }
}
fn expr_generic_argument_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block]
}
fn expr_generic_argument_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_8]
}
fn expr_generic_argument_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Minus] {
        call_now![input, expr_generic_argument_11]
    } else {
        call_now![input, expr_generic_argument_13]
    }
}
fn expr_generic_argument_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal]
}
fn expr_generic_argument_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_10]
}
fn expr_generic_argument_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty]
}
fn expr_generic_argument_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_12]
}
fn expr_generic_argument_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_19]
}
fn expr_generic_argument<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_20]
}
fn minus_prefixed_literal_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Minus] {
        call_now![input, minus_prefixed_literal_2]
    } else {
        call_now![input, minus_prefixed_literal_10]
    }
}
fn minus_prefixed_literal_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal]
}
fn minus_prefixed_literal_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Minus] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn minus_prefixed_literal_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_0, minus_prefixed_literal_1]
}
fn minus_prefixed_literal_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Literal] {
        call_now![input, minus_prefixed_literal_4]
    } else {
        call_now![input, minus_prefixed_literal_9]
    }
}
fn minus_prefixed_literal_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Literal] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn minus_prefixed_literal_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_3]
}
fn minus_prefixed_literal_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentLiteral] {
        call_now![input, minus_prefixed_literal_6]
    } else {
        call_now![input, minus_prefixed_literal_8]
    }
}
fn minus_prefixed_literal_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentLiteral] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn minus_prefixed_literal_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_5]
}
fn minus_prefixed_literal_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn minus_prefixed_literal_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_7]
}
fn minus_prefixed_literal_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_11]
}
fn minus_prefixed_literal<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_12]
}
fn expr_prefixed_unary_op_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input,]
}
fn expr_prefixed_unary_op<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_prefixed_unary_op_0]
}
