// This file is automatically @generated by `grammar-gen`.
// It is not intended for manual editing.
// See the documentation in `expandable` for more information:
// https://github.com/scrabsha/expandable

#![allow(unused, non_snake_case)]
use std::{
    hash::{Hash, Hasher},
    mem,
};

use smallvec::SmallVec;
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub enum TokenDescription {
    Ident,
    As,
    Async,
    Await,
    Break,
    Const,
    Continue,
    Crate,
    Dyn,
    Else,
    Enum,
    Extern,
    False,
    Fn,
    For,
    If,
    Impl,
    In,
    Let,
    Loop,
    Match,
    Mod,
    Move,
    Mut,
    Pub,
    Ref,
    Return,
    Self_,
    SelfUpper,
    Static,
    Struct,
    Super,
    Trait,
    True,
    Type,
    Union,
    Unsafe,
    Use,
    Where,
    While,
    Yield,
    Abstract,
    Become,
    Box,
    Do,
    Final,
    Macro,
    Override,
    Priv,
    Try,
    Typeof,
    Unsized,
    Virtual,
    Literal,
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Caret,
    Not,
    And,
    Or,
    AndAnd,
    OrOr,
    Shl,
    Shr,
    PlusEquals,
    MinusEquals,
    StarEquals,
    SlashEquals,
    PercentEquals,
    CaretEquals,
    AndEquals,
    OrEquals,
    ShlEquals,
    ShrEquals,
    Equals,
    EqualsEquals,
    NotEquals,
    GreaterThan,
    LessThan,
    GreaterThanEquals,
    LessThanEquals,
    At,
    Underscore,
    Dot,
    DotDot,
    DotDotDot,
    DotDotEquals,
    Comma,
    Semicolon,
    Colon,
    ColonColon,
    RightArrow,
    FatArrow,
    Pound,
    Dollar,
    QuestionMark,
    LParen,
    RParen,
    LBracket,
    RBracket,
    LBrace,
    RBrace,
    FragmentBlock,
    FragmentExpr,
    FragmentIdent,
    FragmentItem,
    FragmentLifetime,
    FragmentLiteral,
    FragmentMeta,
    FragmentPat,
    FragmentPath,
    FragmentStmt,
    FragmentTT,
    FragmentTy,
    FragmentVis,
}
use TokenDescription::*;
#[derive(Clone, Debug)]
pub struct RustParser<Span: 'static> {
    buffer: TokenBuffer<Span>,
    stack: Vec<State<Span>>,
    tried: SmallVec<[TokenDescription; 10]>,
}
impl<Span> PartialEq for RustParser<Span> {
    fn eq(&self, other: &RustParser<Span>) -> bool {
        std::ptr::eq(self, other) || (self.buffer == other.buffer && self.stack == other.stack)
    }
}
impl<Span> Hash for RustParser<Span>
where
    Span: 'static,
{
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.buffer.hash(state);
        self.stack.hash(state);
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TransitionData {
    pub popped: usize,
    pub buf_size: usize,
    pub pushed: Vec<&'static str>,
}
impl<Span> RustParser<Span>
where
    Span: Copy + 'static,
{
    pub fn item() -> RustParser<Span> {
        RustParser {
            buffer: TokenBuffer::Empty([]),
            stack: vec![(item, concat!("<", stringify!(item), " entry point>"))],
            tried: SmallVec::new(),
        }
    }

    pub fn ty() -> RustParser<Span> {
        RustParser {
            buffer: TokenBuffer::Empty([]),
            stack: vec![(ty, concat!("<", stringify!(ty), " entry point>"))],
            tried: SmallVec::new(),
        }
    }

    pub fn expr() -> RustParser<Span> {
        RustParser {
            buffer: TokenBuffer::Empty([]),
            stack: vec![(expr, concat!("<", stringify!(expr), " entry point>"))],
            tried: SmallVec::new(),
        }
    }

    pub fn step(
        &mut self,
        token: TokenDescription,
        span: Span,
    ) -> Result<TransitionData, (Span, Vec<TokenDescription>)> {
        match self.buffer.len() {
            buf_size @ (0 | 1) => {
                self.buffer.push(token, span);
                return Ok(TransitionData {
                    popped: 0,
                    buf_size,
                    pushed: vec![],
                });
            }
            2 => {
                self.buffer.push(token, span);
            }
            _ => panic!("Token buffer is full!"),
        };
        self.perform_progress().map_err(|e| match e {
            ProgressError::EmptyStack(s) => (s.unwrap(), vec![]),
            ProgressError::ParsingError(s, expected) => (s.unwrap(), expected),
        })
    }

    pub fn finish(&mut self) -> Result<(), Option<(Span, Vec<TokenDescription>)>> {
        while !self.buffer.is_empty() {
            match self.perform_progress() {
                Ok(_) => continue,
                Err(ProgressError::EmptyStack(s)) => {
                    let e = s.map(|s| (s, vec![]));
                    return Err(e);
                }
                Err(ProgressError::ParsingError(s, e)) => {
                    return Err(s.map(|s| (s, e)));
                }
            }
        }
        while !self.stack.is_empty() {
            match self.perform_progress() {
                Ok(_) => continue,
                Err(ProgressError::EmptyStack(_)) => break,
                Err(ProgressError::ParsingError(s, e)) => {
                    let e = s.map(|s| (s, e));
                    return Err(e);
                }
            }
        }
        Ok(())
    }

    fn perform_progress(&mut self) -> Result<TransitionData, ProgressError<Span>> {
        let mut trans = TransitionData::new_full_buffer();
        self.tried.clear();
        let mut fuel = u8::MAX;
        loop {
            assert!(
                fuel != 0,
                "Out of fuel. This is probably a bug in the parser codegen."
            );
            fuel -= 1;
            trans.log_pop();
            let (state, name) = self.stack.pop().ok_or_else(|| {
                let s = self.buffer.peek().map(|(_, s)| s);
                ProgressError::EmptyStack(s)
            })?;
            match state(self)
                .map_err(|s| ProgressError::ParsingError(s, self.tried.clone().into_vec()))?
            {
                Transition::CallNow(states) => {
                    states.iter().for_each(|(_, fn_)| trans.log_push(fn_));
                    self.stack.extend(states.iter().copied());
                }
                Transition::CallThen(states) => {
                    self.buffer.shift();
                    states.iter().for_each(|(_, fn_)| trans.log_push(fn_));
                    self.stack.extend(states.iter().copied());
                    break Ok(trans);
                }
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
enum ProgressError<Span> {
    EmptyStack(Option<Span>),
    ParsingError(Option<Span>, Vec<TokenDescription>),
}
#[derive(Clone, Debug)]
enum TokenBuffer<Span> {
    Empty([(TokenDescription, Span); 0]),
    Single([(TokenDescription, Span); 1]),
    Double([(TokenDescription, Span); 2]),
    Triple([(TokenDescription, Span); 3]),
}
impl<Span> Hash for TokenBuffer<Span> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        let discriminant = mem::discriminant(self);
        discriminant.hash(state);
        match self {
            TokenBuffer::Empty([]) => <[TokenDescription; 0] as Hash>::hash(&[], state),
            TokenBuffer::Single([(a, _)]) => [a].hash(state),
            TokenBuffer::Double([(a, _), (b, _)]) => [a, b].hash(state),
            TokenBuffer::Triple([(a, _), (b, _), (c, _)]) => [a, b, c].hash(state),
        }
    }
}
impl<Span> PartialEq for TokenBuffer<Span> {
    fn eq(&self, other: &TokenBuffer<Span>) -> bool {
        let self_tag = mem::discriminant(self);
        let arg1_tag = mem::discriminant(other);
        self_tag == arg1_tag
            && match (self, other) {
                (TokenBuffer::Empty([]), TokenBuffer::Empty([])) => true,
                (TokenBuffer::Single([(a, _)]), TokenBuffer::Single([(a_, _)])) => [a] == [a_],
                (
                    TokenBuffer::Double([(a, _), (b, _)]),
                    TokenBuffer::Double([(a_, _), (b_, _)]),
                ) => [a, b] == [a_, b_],
                (
                    TokenBuffer::Triple([(a, _), (b, _), (c, _)]),
                    TokenBuffer::Triple([(a_, _), (b_, _), (c_, _)]),
                ) => [a, b, c] == [a_, b_, c_],
                _ => unreachable!(),
            }
    }
}
impl<Span> Eq for TokenBuffer<Span> {}
type State<Span> = (
    fn(&mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>>,
    &'static str,
);
#[derive(Clone, Copy, Debug, PartialEq)]
enum Transition<Span: 'static> {
    CallNow(&'static [State<Span>]),
    CallThen(&'static [State<Span>]),
}
impl<Span> TokenBuffer<Span>
where
    Span: Copy + 'static,
{
    fn len(&self) -> usize {
        match self {
            TokenBuffer::Empty(_) => 0,
            TokenBuffer::Single(_) => 1,
            TokenBuffer::Double(_) => 2,
            TokenBuffer::Triple(_) => 3,
        }
    }

    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    fn push(&mut self, token: TokenDescription, span: Span) {
        match self {
            TokenBuffer::Empty([]) => {
                *self = TokenBuffer::Single([(token, span)]);
            }
            TokenBuffer::Single([a]) => {
                *self = TokenBuffer::Double([*a, (token, span)]);
            }
            TokenBuffer::Double([a, b]) => {
                *self = TokenBuffer::Triple([*a, *b, (token, span)]);
            }
            TokenBuffer::Triple([a, b, c]) => {
                panic!("Token buffer is full!");
            }
        }
    }

    fn shift(&mut self) -> (TokenDescription, Span) {
        match self {
            TokenBuffer::Empty(_) => panic!("Token buffer is empty!!"),
            TokenBuffer::Single([a]) => {
                let a = *a;
                *self = TokenBuffer::Empty([]);
                a
            }
            TokenBuffer::Double([a, b]) => {
                let a = *a;
                *self = TokenBuffer::Single([*b]);
                a
            }
            TokenBuffer::Triple([a, b, c]) => {
                let a = *a;
                *self = TokenBuffer::Double([*b, *c]);
                a
            }
        }
    }

    fn peek(&self) -> Option<(TokenDescription, Span)> {
        match self {
            TokenBuffer::Empty(_) => None,
            TokenBuffer::Single([a])
            | TokenBuffer::Double([a, _])
            | TokenBuffer::Triple([a, _, _]) => Some(*a),
        }
    }

    fn peek2(&self) -> Option<(TokenDescription, Span)> {
        match self {
            TokenBuffer::Empty(_) | TokenBuffer::Single([_]) => None,
            TokenBuffer::Double([_, a]) | TokenBuffer::Triple([_, a, _]) => Some(*a),
        }
    }

    fn peek3(&self) -> Option<(TokenDescription, Span)> {
        match self {
            TokenBuffer::Empty(_) | TokenBuffer::Single([_]) | TokenBuffer::Double([_, _]) => None,
            TokenBuffer::Triple([_, _, a]) => Some(*a),
        }
    }
}
impl TransitionData {
    pub fn empty() -> TransitionData {
        TransitionData {
            popped: 0,
            buf_size: 0,
            pushed: vec![],
        }
    }

    pub fn combine_chasles(mut self, other: TransitionData) -> TransitionData {
        for _ in 0..other.popped {
            self.log_pop();
        }
        for pushed in other.pushed {
            self.log_push(pushed);
        }
        self
    }

    fn new_full_buffer() -> TransitionData {
        TransitionData {
            popped: 0,
            buf_size: 3,
            pushed: vec![],
        }
    }

    fn log_pop(&mut self) {
        if self.pushed.pop().is_none() {
            self.popped += 1;
        }
    }

    fn log_push(&mut self, state: &'static str) {
        self.pushed.push(state);
    }
}
macro_rules ! call_now { ($ _input : expr $ (, $ arg : expr) * $ (,) ?) => { return Ok ({ Transition :: CallNow (& [$ (($ arg , stringify ! ($ arg))) , *]) }) } ; }
macro_rules ! call_then { ($ input : expr $ (, $ arg : expr) * $ (,) ?) => { Ok ({ Transition :: CallThen (& [$ (($ arg , stringify ! ($ arg))) , *]) }) } ; }
macro_rules ! nothing { [$ _input : expr] => { Ok (Transition :: CallNow (& [])) } ; }
macro_rules! bump {
    ($input:expr) => {{ !$input.buffer.is_empty() }};
    ($input:expr, $token:expr) => {{
        $input.tried.push($token);
        $input
            .buffer
            .peek()
            .map(|(k, _)| k == $token)
            .unwrap_or_default()
    }};
}
macro_rules! error {
    ($input:expr) => {{
        return Err($input.buffer.peek().map(|(_, span)| span));
    }};
}
macro_rules! end {
    ($input:expr) => {{
        return Ok(Transition::CallNow(&[]));
    }};
}
macro_rules! cond {
    ($input:expr, $method:ident) => {{ !$input.buffer.is_empty() }};
    ($input:expr,peek, $expected:expr) => {{
        $input.tried.push($expected);
        $input
            .buffer
            .peek()
            .map(|(k, _)| k == $expected)
            .unwrap_or_default()
    }};
    ($input:expr, $method:ident, $expected:expr) => {{
        $input
            .buffer
            .$method()
            .map(|(k, _)| k == $expected)
            .unwrap_or_default()
    }};
}
fn vis_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LParen] {
        call_now![input, vis_5]
    } else {
        call_now![input,]
    }
}
fn vis_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Crate] {
        call_now![input, vis_2]
    } else {
        call_now![input,]
    }
}
fn vis_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn vis_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn vis_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis_0, vis_1]
}
fn vis_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn vis_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis_3, vis_4]
}
fn vis_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Pub] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn vis_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis_6, vis_7]
}
fn vis<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis_8]
}
fn item_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Fn] {
        call_now![input, item_1]
    } else {
        call_now![input, item_3]
    }
}
fn item_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item]
}
fn item_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_0]
}
fn item_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn item_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_2]
}
fn item_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Pub] {
        call_now![input, item_6]
    } else {
        call_now![input,]
    }
}
fn item_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, vis]
}
fn item_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_5]
}
fn item_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_4, item_7]
}
fn item<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, item_8]
}
fn fn_item_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block]
}
fn fn_item_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RightArrow] {
        call_now![input, fn_item_3]
    } else {
        call_now![input,]
    }
}
fn fn_item_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty]
}
fn fn_item_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_item_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_1, fn_item_2]
}
fn fn_item_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args]
}
fn fn_item_13<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, fn_item_7]
    } else {
        call_now![input, fn_item_12]
    }
}
fn fn_item_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Ident] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_item_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_6]
}
fn fn_item_12<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, fn_item_9]
    } else {
        call_now![input, fn_item_11]
    }
}
fn fn_item_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentIdent] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_item_9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_8]
}
fn fn_item_10<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn fn_item_11<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_10]
}
fn fn_item_14<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Fn] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_item_15<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input, fn_item_0, fn_item_4, fn_item_5, fn_item_13, fn_item_14
    ]
}
fn fn_item<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_item_15]
}
fn block_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBrace] {
        call_now![input, block_1]
    } else {
        call_now![input, block_4]
    }
}
fn block_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBrace] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_0]
}
fn block_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_]
}
fn block_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner]
}
fn block_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_2, block_3]
}
fn block_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LBrace] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_5, block_6]
}
fn block<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_7]
}
fn block__11<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBrace] {
        call_now![input, block__1]
    } else {
        call_now![input, block__10]
    }
}
fn block__0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBrace] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block__1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__0]
}
fn block__10<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Semicolon] {
        call_now![input, block__9]
    } else {
        call_now![input,]
    }
}
fn block__7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBrace] {
        call_now![input, block__3]
    } else {
        call_now![input, block__6]
    }
}
fn block__2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBrace] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block__3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__2]
}
fn block__4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block_]
}
fn block__5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner]
}
fn block__6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__4, block__5]
}
fn block__8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Semicolon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn block__9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__7, block__8]
}
fn block__12<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__11]
}
fn block_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block__12]
}
fn stmt_inner_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn stmt_inner_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Let] {
        call_now![input, stmt_inner_4]
    } else {
        call_now![input,]
    }
}
fn stmt_inner_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Equals] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn stmt_inner_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat]
}
fn stmt_inner_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Let] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn stmt_inner_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner_1, stmt_inner_2, stmt_inner_3]
}
fn stmt_inner_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner_0, stmt_inner_5]
}
fn stmt_inner<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, stmt_inner_6]
}
fn ty_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, ty_1]
    } else {
        call_now![input, ty_6]
    }
}
fn ty_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn ty_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_0]
}
fn ty_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentTy] {
        call_now![input, ty_3]
    } else {
        call_now![input, ty_5]
    }
}
fn ty_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn ty_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_2]
}
fn ty_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn ty_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_4]
}
fn ty_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_7]
}
fn ty<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty_8]
}
fn fn_args_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, fn_args_1]
    } else {
        call_now![input, fn_args_3]
    }
}
fn fn_args_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_0]
}
fn fn_args_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_]
}
fn fn_args_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_2]
}
fn fn_args_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, fn_args_6]
    } else {
        call_now![input,]
    }
}
fn fn_args_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_5]
}
fn fn_args_11<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, fn_args_8]
    } else {
        call_now![input, fn_args_10]
    }
}
fn fn_args_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input,]
}
fn fn_args_9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_arg]
}
fn fn_args_10<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_9]
}
fn fn_args_12<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args_13<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_4, fn_args_7, fn_args_11, fn_args_12]
}
fn fn_args<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args_13]
}
fn fn_args__2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, fn_args__1]
    } else {
        call_now![input,]
    }
}
fn fn_args__0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args__1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args__0]
}
fn fn_args__5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, fn_args__4]
    } else {
        call_now![input,]
    }
}
fn fn_args__3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_args__4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args__3]
}
fn fn_args__6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_arg]
}
fn fn_args__7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args__2, fn_args__5, fn_args__6]
}
fn fn_args_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_args__7]
}
fn pat_10<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, pat_1]
    } else {
        call_now![input, pat_9]
    }
}
fn pat_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn pat_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_0]
}
fn pat_9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, pat_3]
    } else {
        call_now![input, pat_8]
    }
}
fn pat_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn pat_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_2]
}
fn pat_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentPat] {
        call_now![input, pat_5]
    } else {
        call_now![input, pat_7]
    }
}
fn pat_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn pat_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_4]
}
fn pat_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn pat_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_6]
}
fn pat_11<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_10]
}
fn pat<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat_11]
}
fn fn_arg_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty]
}
fn fn_arg_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Colon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn fn_arg_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, pat]
}
fn fn_arg_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_arg_0, fn_arg_1, fn_arg_2]
}
fn fn_arg<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, fn_arg_3]
}
fn expr_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom]
}
fn expr_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_prefixed_unary_op]
}
fn expr_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_0, expr_1, expr_2]
}
fn expr<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_3]
}
fn expr_after_atom_23<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Plus]
        || cond![input, peek, Minus]
        || cond![input, peek, Star]
        || cond![input, peek, Slash]
        || cond![input, peek, Percent]
        || cond![input, peek, And]
        || cond![input, peek, Or]
        || cond![input, peek, Caret]
        || cond![input, peek, Shl]
        || cond![input, peek, Shr]
    {
        call_now![input, expr_after_atom_2]
    } else {
        call_now![input, expr_after_atom_22]
    }
}
fn expr_after_atom_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_0, expr_after_atom_1]
}
fn expr_after_atom_22<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, EqualsEquals]
        || cond![input, peek, NotEquals]
        || cond![input, peek, GreaterThan]
        || cond![input, peek, LessThan]
        || cond![input, peek, GreaterThanEquals]
        || cond![input, peek, LessThanEquals]
    {
        call_now![input, expr_after_atom_5]
    } else {
        call_now![input, expr_after_atom_21]
    }
}
fn expr_after_atom_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_3, expr_after_atom_4]
}
fn expr_after_atom_21<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, OrOr] || cond![input, peek, AndAnd] {
        call_now![input, expr_after_atom_8]
    } else {
        call_now![input, expr_after_atom_20]
    }
}
fn expr_after_atom_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_6, expr_after_atom_7]
}
fn expr_after_atom_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, DotDot] || cond![input, peek, DotDotEquals] {
        call_now![input, expr_after_atom_11]
    } else {
        call_now![input, expr_after_atom_19]
    }
}
fn expr_after_atom_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_after_atom_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_after_atom_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_9, expr_after_atom_10]
}
fn expr_after_atom_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LParen] {
        call_now![input, expr_after_atom_14]
    } else {
        call_now![input, expr_after_atom_18]
    }
}
fn expr_after_atom_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom]
}
fn expr_after_atom_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call]
}
fn expr_after_atom_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_12, expr_after_atom_13]
}
fn expr_after_atom_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Dot] {
        call_now![input, expr_after_atom_17]
    } else {
        call_now![input,]
    }
}
fn expr_after_atom_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom]
}
fn expr_after_atom_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr]
}
fn expr_after_atom_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_15, expr_after_atom_16]
}
fn expr_after_atom_24<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_23]
}
fn expr_after_atom<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_after_atom_24]
}
fn expr_atom_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Return] || cond![input, peek, Break] {
        call_now![input, expr_atom_1]
    } else {
        call_now![input, expr_atom_18]
    }
}
fn expr_atom_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break]
}
fn expr_atom_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_0]
}
fn expr_atom_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident]
        || cond![input, peek, FragmentIdent]
        || cond![input, peek, ColonColon]
    {
        call_now![input, expr_atom_3]
    } else {
        call_now![input, expr_atom_17]
    }
}
fn expr_atom_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path]
}
fn expr_atom_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_2]
}
fn expr_atom_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentExpr] || cond![input, peek, Literal] {
        call_now![input, expr_atom_5]
    } else {
        call_now![input, expr_atom_16]
    }
}
fn expr_atom_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_atom_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_4]
}
fn expr_atom_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, If] {
        call_now![input, expr_atom_7]
    } else {
        call_now![input, expr_atom_15]
    }
}
fn expr_atom_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_if]
}
fn expr_atom_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_6]
}
fn expr_atom_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LBracket] {
        call_now![input, expr_atom_9]
    } else {
        call_now![input, expr_atom_14]
    }
}
fn expr_atom_8<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array]
}
fn expr_atom_9<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_8]
}
fn expr_atom_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LBrace] {
        call_now![input, expr_atom_11]
    } else {
        call_now![input, expr_atom_13]
    }
}
fn expr_atom_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block]
}
fn expr_atom_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_10]
}
fn expr_atom_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn expr_atom_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_12]
}
fn expr_atom_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_19]
}
fn expr_atom<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom_20]
}
fn expr_return_or_break_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Async]
        || cond![input, peek, Break]
        || cond![input, peek, Continue]
        || cond![input, peek, Crate]
        || cond![input, peek, False]
        || cond![input, peek, For]
        || cond![input, peek, Let]
        || cond![input, peek, Loop]
        || cond![input, peek, Match]
        || cond![input, peek, Move]
        || cond![input, peek, Return]
        || cond![input, peek, Self_]
        || cond![input, peek, SelfUpper]
        || cond![input, peek, True]
        || cond![input, peek, Union]
        || cond![input, peek, While]
        || cond![input, peek, Yield]
        || cond![input, peek, Ident]
        || cond![input, peek, FragmentIdent]
        || cond![input, peek, LParen]
        || cond![input, peek, LBracket]
        || cond![input, peek, LBrace]
        || cond![input, peek, Literal]
        || cond![input, peek, FragmentLiteral]
        || cond![input, peek, Not]
        || cond![input, peek, Star]
        || cond![input, peek, Or]
        || cond![input, peek, And]
        || cond![input, peek, DotDot]
        || cond![input, peek, LessThan]
        || cond![input, peek, ColonColon]
        || cond![input, peek, Pound]
        || cond![input, peek, FragmentExpr]
    {
        call_now![input, expr_return_or_break_1]
    } else {
        call_now![input,]
    }
}
fn expr_return_or_break_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_atom]
}
fn expr_return_or_break_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_0]
}
fn expr_return_or_break_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Return] {
        call_now![input, expr_return_or_break_4]
    } else {
        call_now![input, expr_return_or_break_9]
    }
}
fn expr_return_or_break_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Return] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_return_or_break_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_3]
}
fn expr_return_or_break_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Break] {
        call_now![input, expr_return_or_break_6]
    } else {
        call_now![input, expr_return_or_break_8]
    }
}
fn expr_return_or_break_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Break] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_return_or_break_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_5]
}
fn expr_return_or_break_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn expr_return_or_break_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_7]
}
fn expr_return_or_break_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_2, expr_return_or_break_10]
}
fn expr_return_or_break<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_return_or_break_11]
}
fn expr_path_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, ColonColon] {
        call_now![input, expr_path_1]
    } else {
        call_now![input,]
    }
}
fn expr_path_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_]
}
fn expr_path_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_0]
}
fn expr_path_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_segment]
}
fn expr_path_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, ColonColon] {
        call_now![input, expr_path_5]
    } else {
        call_now![input,]
    }
}
fn expr_path_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, ColonColon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_path_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_4]
}
fn expr_path_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_2, expr_path_3, expr_path_6]
}
fn expr_path<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_7]
}
fn expr_path__2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, ColonColon] {
        call_now![input, expr_path__1]
    } else {
        call_now![input,]
    }
}
fn expr_path__0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_]
}
fn expr_path__1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path__0]
}
fn expr_path__3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_segment]
}
fn expr_path__4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, ColonColon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_path__5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path__2, expr_path__3, expr_path__4]
}
fn expr_path_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path__5]
}
fn expr_path_segment_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, ColonColon] {
        call_now![input, expr_path_segment_4]
    } else {
        call_now![input,]
    }
}
fn expr_path_segment_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek2, LessThan] {
        call_now![input, expr_path_segment_2]
    } else {
        call_now![input,]
    }
}
fn expr_path_segment_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments]
}
fn expr_path_segment_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, ColonColon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_path_segment_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_segment_0, expr_path_segment_1]
}
fn expr_path_segment_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_segment_3]
}
fn expr_path_segment_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, path_segment]
}
fn expr_path_segment_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_segment_5, expr_path_segment_6]
}
fn expr_path_segment<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_path_segment_7]
}
fn path_segment_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident]
        || cond![input, peek, FragmentIdent]
        || cond![input, peek, SelfUpper]
    {
        call_now![input, path_segment_1]
    } else {
        call_now![input, path_segment_3]
    }
}
fn path_segment_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn path_segment_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, path_segment_0]
}
fn path_segment_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn path_segment_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, path_segment_2]
}
fn path_segment_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, path_segment_4]
}
fn path_segment<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, path_segment_5]
}
fn expr_if_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Else] {
        call_now![input, expr_if_2]
    } else {
        call_now![input,]
    }
}
fn expr_if_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_block]
}
fn expr_if_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Else] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_if_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_if_0, expr_if_1]
}
fn expr_if_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_block]
}
fn expr_if_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_if_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, If] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_if_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_if_3, expr_if_4, expr_if_5, expr_if_6]
}
fn expr_if<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_if_7]
}
fn expr_array_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBracket] {
        call_now![input, expr_array_1]
    } else {
        call_now![input, expr_array_10]
    }
}
fn expr_array_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_0]
}
fn expr_array_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Semicolon] {
        call_now![input, expr_array_5]
    } else {
        call_now![input, expr_array_7]
    }
}
fn expr_array_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_array_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Semicolon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_2, expr_array_3, expr_array_4]
}
fn expr_array_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_]
}
fn expr_array_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_6]
}
fn expr_array_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_array_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_8, expr_array_9]
}
fn expr_array_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_11, expr_array_12]
}
fn expr_array<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_13]
}
fn expr_array__10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, expr_array__7]
    } else {
        call_now![input, expr_array__9]
    }
}
fn expr_array__5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RBracket] {
        call_now![input, expr_array__1]
    } else {
        call_now![input, expr_array__4]
    }
}
fn expr_array__0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array__1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__0]
}
fn expr_array__2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array_]
}
fn expr_array__3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_array__4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__2, expr_array__3]
}
fn expr_array__6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array__7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__5, expr_array__6]
}
fn expr_array__8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RBracket] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_array__9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__8]
}
fn expr_array__11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__10]
}
fn expr_array_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_array__11]
}
fn expr_block_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block]
}
fn expr_block_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_block_0]
}
fn expr_block<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_block_1]
}
fn expr_call_5<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, expr_call_1]
    } else {
        call_now![input, expr_call_4]
    }
}
fn expr_call_0<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call_1<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_0]
}
fn expr_call_2<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_]
}
fn expr_call_3<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_call_4<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_2, expr_call_3]
}
fn expr_call_6<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call_7<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_5, expr_call_6]
}
fn expr_call<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_7]
}
fn expr_call__10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, expr_call__7]
    } else {
        call_now![input, expr_call__9]
    }
}
fn expr_call__5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, RParen] {
        call_now![input, expr_call__1]
    } else {
        call_now![input, expr_call__4]
    }
}
fn expr_call__0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call__1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__0]
}
fn expr_call__2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call_]
}
fn expr_call__3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr]
}
fn expr_call__4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__2, expr_call__3]
}
fn expr_call__6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call__7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__5, expr_call__6]
}
fn expr_call__8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, RParen] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_call__9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__8]
}
fn expr_call__11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__10]
}
fn expr_call_<Span: Copy>(input: &mut RustParser<Span>) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call__11]
}
fn expr_dot_expr_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Await] {
        call_now![input, expr_dot_expr_1]
    } else {
        call_now![input, expr_dot_expr_19]
    }
}
fn expr_dot_expr_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Await] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_0]
}
fn expr_dot_expr_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, expr_dot_expr_4]
    } else {
        call_now![input, expr_dot_expr_18]
    }
}
fn expr_dot_expr_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method]
}
fn expr_dot_expr_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Ident] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_2, expr_dot_expr_3]
}
fn expr_dot_expr_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, expr_dot_expr_7]
    } else {
        call_now![input, expr_dot_expr_17]
    }
}
fn expr_dot_expr_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method]
}
fn expr_dot_expr_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentIdent] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_5, expr_dot_expr_6]
}
fn expr_dot_expr_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Literal] {
        call_now![input, expr_dot_expr_10]
    } else {
        call_now![input, expr_dot_expr_16]
    }
}
fn expr_dot_expr_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method]
}
fn expr_dot_expr_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Literal] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_8, expr_dot_expr_9]
}
fn expr_dot_expr_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentLiteral] {
        call_now![input, expr_dot_expr_13]
    } else {
        call_now![input, expr_dot_expr_15]
    }
}
fn expr_dot_expr_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method]
}
fn expr_dot_expr_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentLiteral] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_11, expr_dot_expr_12]
}
fn expr_dot_expr_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn expr_dot_expr_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_14]
}
fn expr_dot_expr_21<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Dot] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_dot_expr_22<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_20, expr_dot_expr_21]
}
fn expr_dot_expr<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_dot_expr_22]
}
fn expr_field_or_method_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LParen] {
        call_now![input, expr_field_or_method_1]
    } else {
        call_now![input,]
    }
}
fn expr_field_or_method_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call]
}
fn expr_field_or_method_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method_0]
}
fn expr_field_or_method_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, ColonColon] {
        call_now![input, expr_field_or_method_6]
    } else {
        call_now![input,]
    }
}
fn expr_field_or_method_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_call]
}
fn expr_field_or_method_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments]
}
fn expr_field_or_method_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, ColonColon] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_field_or_method_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_field_or_method_3,
        expr_field_or_method_4,
        expr_field_or_method_5
    ]
}
fn expr_field_or_method_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method_2, expr_field_or_method_7]
}
fn expr_field_or_method<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_field_or_method_8]
}
fn expr_angle_bracketed_generic_arguments_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, GreaterThan] {
        call_now![input, expr_angle_bracketed_generic_arguments_1]
    } else {
        call_now![input, expr_angle_bracketed_generic_arguments_4]
    }
}
fn expr_angle_bracketed_generic_arguments_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, GreaterThan] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments_0]
}
fn expr_angle_bracketed_generic_arguments_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments_]
}
fn expr_angle_bracketed_generic_arguments_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument]
}
fn expr_angle_bracketed_generic_arguments_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_angle_bracketed_generic_arguments_2,
        expr_angle_bracketed_generic_arguments_3
    ]
}
fn expr_angle_bracketed_generic_arguments_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, LessThan] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_angle_bracketed_generic_arguments_5,
        expr_angle_bracketed_generic_arguments_6
    ]
}
fn expr_angle_bracketed_generic_arguments<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments_7]
}
fn expr_angle_bracketed_generic_arguments__11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, GreaterThan] {
        call_now![input, expr_angle_bracketed_generic_arguments__1]
    } else {
        call_now![input, expr_angle_bracketed_generic_arguments__10]
    }
}
fn expr_angle_bracketed_generic_arguments__0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, GreaterThan] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments__1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments__0]
}
fn expr_angle_bracketed_generic_arguments__10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Comma] {
        call_now![input, expr_angle_bracketed_generic_arguments__9]
    } else {
        call_now![input,]
    }
}
fn expr_angle_bracketed_generic_arguments__7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, GreaterThan] {
        call_now![input, expr_angle_bracketed_generic_arguments__3]
    } else {
        call_now![input, expr_angle_bracketed_generic_arguments__6]
    }
}
fn expr_angle_bracketed_generic_arguments__2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, GreaterThan] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments__3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments__2]
}
fn expr_angle_bracketed_generic_arguments__4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments_]
}
fn expr_angle_bracketed_generic_arguments__5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument]
}
fn expr_angle_bracketed_generic_arguments__6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_angle_bracketed_generic_arguments__4,
        expr_angle_bracketed_generic_arguments__5
    ]
}
fn expr_angle_bracketed_generic_arguments__8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Comma] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_angle_bracketed_generic_arguments__9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![
        input,
        expr_angle_bracketed_generic_arguments__7,
        expr_angle_bracketed_generic_arguments__8
    ]
}
fn expr_angle_bracketed_generic_arguments__12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments__11]
}
fn expr_angle_bracketed_generic_arguments_<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_angle_bracketed_generic_arguments__12]
}
fn expr_generic_argument_19<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Literal] {
        call_now![input, expr_generic_argument_1]
    } else {
        call_now![input, expr_generic_argument_18]
    }
}
fn expr_generic_argument_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Literal] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_generic_argument_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_0]
}
fn expr_generic_argument_18<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentLiteral] {
        call_now![input, expr_generic_argument_3]
    } else {
        call_now![input, expr_generic_argument_17]
    }
}
fn expr_generic_argument_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentLiteral] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_generic_argument_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_2]
}
fn expr_generic_argument_17<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Ident] {
        call_now![input, expr_generic_argument_5]
    } else {
        call_now![input, expr_generic_argument_16]
    }
}
fn expr_generic_argument_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Ident] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_generic_argument_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_4]
}
fn expr_generic_argument_16<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentIdent] {
        call_now![input, expr_generic_argument_7]
    } else {
        call_now![input, expr_generic_argument_15]
    }
}
fn expr_generic_argument_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentIdent] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn expr_generic_argument_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_6]
}
fn expr_generic_argument_15<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, LBrace] {
        call_now![input, expr_generic_argument_9]
    } else {
        call_now![input, expr_generic_argument_14]
    }
}
fn expr_generic_argument_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, block]
}
fn expr_generic_argument_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_8]
}
fn expr_generic_argument_14<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Minus] {
        call_now![input, expr_generic_argument_11]
    } else {
        call_now![input, expr_generic_argument_13]
    }
}
fn expr_generic_argument_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal]
}
fn expr_generic_argument_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_10]
}
fn expr_generic_argument_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, ty]
}
fn expr_generic_argument_13<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_12]
}
fn expr_generic_argument_20<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_19]
}
fn expr_generic_argument<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_generic_argument_20]
}
fn minus_prefixed_literal_11<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Minus] {
        call_now![input, minus_prefixed_literal_2]
    } else {
        call_now![input, minus_prefixed_literal_10]
    }
}
fn minus_prefixed_literal_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal]
}
fn minus_prefixed_literal_1<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Minus] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn minus_prefixed_literal_2<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_0, minus_prefixed_literal_1]
}
fn minus_prefixed_literal_10<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, Literal] {
        call_now![input, minus_prefixed_literal_4]
    } else {
        call_now![input, minus_prefixed_literal_9]
    }
}
fn minus_prefixed_literal_3<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, Literal] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn minus_prefixed_literal_4<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_3]
}
fn minus_prefixed_literal_9<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if cond![input, peek, FragmentLiteral] {
        call_now![input, minus_prefixed_literal_6]
    } else {
        call_now![input, minus_prefixed_literal_8]
    }
}
fn minus_prefixed_literal_5<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    if bump![input, FragmentLiteral] {
        call_then![input,]
    } else {
        error![input]
    }
}
fn minus_prefixed_literal_6<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_5]
}
fn minus_prefixed_literal_7<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    error![input]
}
fn minus_prefixed_literal_8<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_7]
}
fn minus_prefixed_literal_12<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_11]
}
fn minus_prefixed_literal<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, minus_prefixed_literal_12]
}
fn expr_prefixed_unary_op_0<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input,]
}
fn expr_prefixed_unary_op<Span: Copy>(
    input: &mut RustParser<Span>,
) -> Result<Transition<Span>, Option<Span>> {
    call_now![input, expr_prefixed_unary_op_0]
}
